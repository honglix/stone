---
layout: post
title: 变量的声明与定义
---
近十年来动态语言越发流行，逐渐侵蚀原本属于静态语言的开发市场，而其中势头最为迅猛的莫过于Python，JavaScript之流。而在这些语言的使用过程中，变量的声明与定义之间的边界似乎变得越发模糊。

## 声明与定义

与静态语言不同，动态语言在使用变量之前并不需要对变量的类型进行声明，比如在JavaScript中，要使用变量只需要通过某个关键字进行简单声明，然后可以对该变量赋予任何类型的值，比如JavaScript

``` javascript
> let a
undefined
> typeof a
'undefined'
> a = 1000
1000
> typeof a
'number'
> a = {}
{}
> typeof a
'object'
```

甚至有些语言连声明都不需要，直接赋值即可，比如说Ruby

``` ruby
> puts a
Traceback (most recent call last):

> a = 1
 => 1
> puts a
1
```

Python也有差不多的行为，然而这些行为我们都习以为常了，在这些动态语言里面声明与定义之间的界线变得越发模糊起来，为了更好地体会声明这一行为，或许JavaScript是更好的教材。

前面也说过，许多动态语言里面，变量的声明与定义都混在一起了，以至于我们察觉不到有声明的存在。其实写JavaScript的时候也可以这样，许多人都会在变量声明的同时对变量进行赋值，比如:


``` node
// example_normal.js
var a = 100
console.log(a)
// => 100
```

这看起来似乎跟Ruby，Python之流没什么区别，这就是变量定义嘛，没有声明啊。很好，接下来考虑这个代码

``` node
// example_with_var.js
console.log(a)
// => undefined
var a = 100
console.log(a)
// => 100
```

要是在正常的语言里面上述语句就会报错了，然而在JavaScript里却不会，第一条打印语句会打印出`undefined`，第二条打印语句会打印出变量`a`的值。第二条语句很好理解，那违和第一条语句不会报错？原因在于`var`关键字有一个叫做**声明提前**的机制，上述脚本会等同于下面这个脚本

``` node
var a
console.log(a) // => undefined
a = 100
console.log(a) // => 100
```

因为引擎会把声明提升到作用域的最前面，所以要打印`a`的时候并不会抱错，而是会返回`undefeind`，最后等到赋值语句运行完再打印，便会输出期望值`100`。这种机制好是好，但在某种程度上可能会写出让人困惑的代码。于是ES6之后出现了`let`和`const`关键字，使用这些新的关键字不仅可以拥有块级作用域，并且在某种程度上也能够防止**声明提前**。以下两句代码都会报`ReferenceError: a is not defined`这个错误

``` node
// example1.js
console.log(a)
const a = 100
```

``` node
// example2.js
console.log(a)
let a = 100
```

## ES6之后还需要声明提前吗

ES6推行之后JavaScript这门语言多了许多“优秀的特征”-或许吧。在某种程度上它们填补了JavaScript原来不足的地方（或者说是把缺陷掩盖）。比如说上面谈到的`const`和`let`关键字，强制用户写出更加容易维护的代码，起码你不至于把代码写成这个样子

``` node
var a = 100

function m() {
  console.log('Before loop', a) // Before loop undefined
  for (a = 0; a < 10; a++) {
    var a
  }

  console.log('Before loop', a) // Before loop 10
}

m()

console.log('out of m', a) // out of m 100
```

十分反人类是吧，因为没有块级作用域，循环内声明的变量`a`进行了声明提前跑到循环外面去了，但是却无法逃脱函数的作用域，最后导致了在函数作用域内的变量`a`遮蔽住了外层的变量`a`，于是乎就导致了函数中的第一条打印语句只能打印出`undefined`, 函数中第二条循环语句打印出`a`后来的值，但是这一切都不会影响到函数外层作用域中的变量`a`。

问题又来了，是不是ES6之后我们再也用不上**声明提前**这个有用，有时候却又难以控制的特性呢？我相信是答案是否定的，因为会声明提前的不仅仅是变量，考虑下面的代码

==========================================================

``` node
m()

function m() {
  console.log('Before loop', a) // Before loop undefined
  for (a = 0; a < 10; a++) {
    var a
  }

  console.log('Before loop', a) // Before loop 10
}
```

最终结果是函数m的调用并不会报错，哪怕我们把函数的声明定义放在后头，这是因为`function`关键字放在行的最开头的时候，会被看成是**声明式**语法，我们都还记得声明会被提升吧。所以上面语句其实也就相当于函数的声明与定义的过程被提到了当前作用域的顶部。

这是JavaScript脚本里面很常见的用法，很多时候我们其实并不会真的从头到尾按顺序地去定义函数，采用声明式的语法就能忽略掉定义顺序的问题。哪怕在`ES6`的箭头函数出现之后这依旧是很有用的特性。

## 声明与定义

变量在使用之前必须进行声明与定义吗？我理解是的，只是随着语言不同变量的声明与定义的方式不太一样。就拿Ruby来举个例子，如果我们想要使用Ruby中的局部变量并不需要对它进行声明，但是必须对它进行定义，否则会报运行时的错误

```
> puts a // => NameError (undefined local variable or method `a' for main:Object)
> a = 1
> puts a // => a
```

但这并不意味着Ruby中的变量就不需要进行声明，只不过是对于局部变量这个角色，Ruby的机制是把定义与声明都放在一起了。用户几乎体会不到声明的过程。Ruby中的实例变量就做得更过分了

```
> puts @a
 => nil
> puts @b
 => nil
> puts @c
 => nil
```

可见只要前面带个`@`的实例变量，即便是没有对该变量进行初始化依旧不会报错，可以理解为Ruby的底层会隐式地帮我们处理这种情况。

在动态语言里面声明似乎变得不那么重要了，一方面是我们并不需要太过于迁就编译器，需要让编译器提前知道我们需要用到的变量是什么类型，并提前分配内存，于是一些语言里面甚至还不会有像JavaScript那样用于声明的关键字比如`let`, `const`, `var`等等。另一方面是动态语言普遍都会有一个叫做类型推导的机制，它们会根据我们对变量所赋得值来判断该变量的类型。

```
> a = 1
 => 1
> a.class
 => Integer
> a = "Beansmile"
 => "Beansmile"
> a.class
 => String
```

我们甚至可以改变变量的指向，用它来保存不同类型的值，这在一些静态语言里面几乎无法做到，因为它们一经声明变量的类型就已经确定了。像下面这个C代码，对整型的变量a赋一个浮点型的值在编译截断就会报警告。因为它会把浮点类型的数值进行隐式转换，不然无法存进一个整型的变量中。

```
int main() {
  int a;
  a = 1222.3;
  printf("%f", a);
}

```

## 后话

总的来说，变量的声明与定义对于任何一门编程语言来说都是较为重要的概念，或许它们已经普遍到我们几乎意识不到它们的存在，然而在不同语言里面它们的侧重点不同。在JavaScript里面在使用一个变量之前必须对它进行声明(当然全局变量除外)，在Ruby中几乎看不到声明的过程，我们可以理解为变量在初始化的时候，底层已经对它进行了相关的声明。而在类似C这些静态语言中，声明尤其重要，因为在使用变量之前编译器需要提前知道它们的类型，一方面用于分配内存，另一方面有些错误就可以在编译的时候被发现了。

那么问题来了，你会喜欢需要一大堆类型声明的编程语言吗？反正我是不怎么喜欢了。Typescript哭晕在厕所....
