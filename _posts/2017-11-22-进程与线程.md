---
layout: post
title: 进程与线程
slug: jin-cheng-yu-xian-cheng
---
最近把跑步改成室内运动之后时间是省下了一些，但是却失去了写作的灵感。近期为了恶补进程方面的盲点阅读了一些相关的东西，东西是了解到一些了，但是却无法用语言表达出来。可见跑步实在不能抛弃，接下来一起看看程序世界里面的高并发。

## 先普及一下知识

一下也算是个人对进程的一些学习笔记吧。仅供参考

### 1. 进程与线程有何区别

有人在[stackoverflow](https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread)概括得比较全面，线程就是轻量级的进程，一般进程都有自己的一部分独立的系统资源，彼此是隔离的。为了能使不同的进程互相访问资源并进行协调工作，就需要用到进程间的通信。而线程而采用共享内存空间的形式，多个线程可以共享同一份内存空间，这样就减少了任务之间通信的成本。

### 2. 并行与并发

采用多线程或者多进程的方式进行开发的方式称为并发，有些语言甚至可以充分利用电脑CPU的多核特征实现并行。那么并行与并发又有何区别？这里有比较有意思的解答[Github](https://github.com/forhappy/Cplusplus-Concurrency-In-Practice/blob/master/zh/chapter1-Introduction/1.1%20What%20is%20concurrency.md)。

总的来讲，并行就是两个任务同时执行，而并发则是同一时间段两个任务交替执行。并行强调的是同一时间点两个任务同时执行，而并发强调的是同一时间段两个任务同时执行。可以考虑下面一个场景。

## 借Ruby来谈并发

传统意义上的Ruby--MRI，具有Thread这个类，也就是说它是支持高并发的，我们可以用这个类来创建多个线程实例，然而在Ruby里面我们却只能实现并发，它并不能活用电脑的CPU多核特征真正实现并行。下面我通过故事的方式来讲。

### 1) GIL的约束

得益于[GIL](https://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81)的存在，Ruby只能够实现并发，并无法利用CPU的多核特征，实现并行任务，并加快程序的运行。

我们的线程只有在拿到GIL锁的时候才能够运行，也就是说即便我们创建的线程再多，本质上也就只有一个线程实例能够拿到GIL，这样某一时刻便只能有一个线程在运行。

可以考虑下面这样的场景

老师给小蓝安排了除草任务，小蓝为了加快速度呼唤了好友小张，然而除草任务需要有锄头才能进行。为此，即便有好有相帮锄头只有一把所以两个人无法同时完成除草的任务，只有拿到锄头使用权的一方才能够进行除草。这把锄头就像是解析器中的GIL，把小张跟小蓝想象成被创建的两个线程，当两个人的工作效率一样的时候，受限于锄头这个约束并无法一同进行除草任务，只能够交替使用锄头，本质上并不会减少工作时间，反而会在换人的时候（上下文切换）耗费掉一定的时间。

很多场景下开更多的线程并不能真正地减少程序的运行时间，反而有可能会随着增加更多的进程而增加上下文切换的开销，从而导致程序变得更慢。

### 2) 并发的作用

从前面的故事可以看出，得益于GIL的存在，多线程并不能带来性能上的提升，反而会因为开的线程太多，导致上下文开销变大，从而增加程序的运行时间。那么并发是否就没有作用了？当然不是，下面再看一个场景

在不能运用计算机多核的程序里面，我们每个时间点只能有一个CPU在工作，并且只有一个任务在运行。回想我们小时后玩的坦克大战的游戏。假设我们有坦克A， 坦克B，坦克A需要向右移动200px，坦克B需要向上移动100px，如果我们是单线程运行的话，那么只能够等坦克A向右移动200px之后，坦克B才能向上移动100px，这样的游戏体验肯定是很糟糕的，这就是我们的串行开发所不能适用的场景，它必须要先完成一个任务然后再开始其他任务。

然而如果我们采用多线程实现的并发开发便能够很好地解决这种问题了。因为线程默认由系统进行调度，在某个时间段内这些线程可以轮流使用CPU，这样就可能实现，坦克A向右移动一小段位置可能是1~2px然后坦克B的线程占用了CPU，坦克B得以向上移动一小段位置，如此循环反复直到任务完成。另外，由于两个线程之间上下文切换是很快的用户几乎察觉不到中间的停顿，所以可以给用户造成一种“两辆坦克同时移动”的假象，当然如果是能够并行开发的语言确实能够使得两辆坦克**同时移动**。

### 3) 多线程需要额外保障

我们前面也说了线程是轻量级的线程，他们共享内存空间，这会造成什么问题呢，如果我们为某个操作添加了10个线程，我们处理一个复杂操作的过程中，系统把控制权让给了其他线程，然而我这个线程的任务只是处理了一半，其他线程无法享受这个线程的任务成果，便可能导致结果与我们期望不符。这样说可能有点迷糊，我举个Ruby例子来说明一下这一点。

``` ruby
a = 0

threads = (1..10).map do |i|
  Thread.new(i) do |i|
    c = a
    sleep(rand(0..1))
    c += 10
    sleep(rand(0..1))
    a = c
  end
end

threads.each { |t| t.join }

puts a
```

这段代码要实现的功能很简单，只是把变量a累加10次，每次加10，并且开了10个线程去完成这个任务。正常情况下我们期望的值是`a == 100`，然而事实却是

```
> ruby a.rb
10

> ruby a.rb
10

> ruby a.rb
30

> ruby a.rb
20
```

怎么可能有这种随机的值？如果不信的话你可以把程序拷贝到自己的电脑去运行一下，出现这种情况的原因是，当我们的操作(这里为了显示出问题，我们采用了sleep方法来把控制权让给其他线程，而在现实中，线程间的上下文切换默认是由系统来调度，我们很难分析出它的具体行为)执行到一半的时候其他线程介入了，导致了数据混乱，考虑下面这个场景

线程1执行了`c = a`之后让出了系统控制权，然后线程二执行了`c = a; c += 10; a = c`，这个时候我们得到`a == 10 && a == c`， 然而这个时候控制权让回给线程1继续往下执行`c += 10, a = c`，由于在线程1的上下文中c还是原来的数值0,所以执行这个操作之后`a == 10 && a == c`，覆盖了线程二的操作结果，无法得到我们心目中的值`20`，线程越多这个过程可能会越乱，更加难以分析。

为了解决这种问题，我们常用的方法是给某个代码块或者变量加锁，它正在被一个线程访问的时候不允许其他线程来介入。修改后的代码如下

``` ruby
a = 0
mutex = Mutex.new

threads = (1..10).map do |i|
  Thread.new(i) do |i|
    # 加锁
    mutex.synchronize do
      c = a
      sleep(rand(0..1))
      c += 10
      sleep(rand(0..1))
      a = c
    end
  end
end

threads.each { |t| t.join }

puts a
```

加上锁之后我们的运行结果就能得到保证了

```
> ruby a.rb
100

> ruby a.rb
100
```

PS: 从前面的知识可以知道，如果只是运用计算机单核所形成的并发操作其实并不能真正提高程序的运行效率，反而会因为上下文的切换而拖慢程序运行速度，而加上锁机制就更加会增加程序的开销，所以当我们使用多线程的时候首先要考虑到使用场景中并发的必要性，并且也要分析自己需要使用的线程数量，毕竟线程这东西并不是越多越好，另外为了保障程序的运行我们还要加上锁，忘了加锁所导致的程序错误往往更加难以察觉。

### 4) 协程与线程

上面说了线程的种种问题，以及它是由系统调度的，我们很难控制并预测它的行为，如果不能够使用计算机多核的情况下它们运行起来可能比串行程序还要慢。那现在说一个高端点的线程-协程。

协程也是线程的一种，但是它与传统的线程还是有点区别，Ruby在1.9之后开始支持`Fiber`使用它就可以写出协程的程序。在某些场景下(特别是Web领域)协程会比线程更加适用。

我举个比较简单的场景的去聊聊这个事情

小蓝被布置了需要完成语文，数学，英语三门功课，预计每门功课需要一个小时的时间去完成。那完成3门功课则大约需要3个小时。小蓝可以采用下面两种工作方式

## 1. 系统调度线程的方式

如果从系统默认调度线程的方式来看，我们以5分钟作为一个时间片段，每5分钟小蓝就需要换一门功课去做，比如正在做着语文，然后5分钟之后会切换到数学，或者英语，做5分钟后，又切换到另外两门功课中的一门。如此反复，直到3门功课都完成之后小蓝就可以休息。这看起来有点疯狂，但是这也是计算机线程上下文切换的方式，但是如果让人类来承受这种上下文切换成本的话我相信是个人都会疯掉。如果你要求小蓝这样去写作业的话，估计不到3个小时它就已经疯了，另外归咎于如此频繁的上下文切换，完成功课的时间肯定是要大于预计的3个小时。

## 2. 协程的工作方式

从上面的工作方式可以看出，系统默认的线程调度方式在有些场景下会过度消耗计算资源，无故增加运行时间，并且有点反人类。在人类的角度来考虑面对3门功课我们更人性化的做法会是，先完成一门然后再去完成下一门。我们或许可以把这个过程想象成一队列。这个过程就有点像线程之间可以相互协作来完成任务，避免不必要的上下文切换，具体是否把控制权让给其他线程，由当前这个线程来决定，而不是让操作系统按照优先级来随机调度。在某种程度上可以减少了不必要的线程切换。我们可以通过这种方式编写出非堵塞的应用程序。

Ruby1.9引入了Fiber后使得我们可以在代码中使用协程。下面是一个Ruby的简单的例子

``` ruby
require 'fiber'
fiber1 = Fiber.new do
  puts "In Fiber 1"
  Fiber.yield
end

fiber2 = Fiber.new do
  puts "In Fiber 2"
  fiber1.transfer
  puts "Never see this message"
end

fiber3 = Fiber.new do
  puts "In Fiber 3"
end

fiber2.resume
fiber3.resume
```

Fiber是Ruby用于创建协程的类，在正式调度之前我们首先创建fiber1~3，三个协程用例，然后在后面的代码中对实例进行调度。首先是fiber2被调度，然后从fiber2内部去把控制权转移给fiber1， 故而"Never see this message"这条信息永远不会被打印。最后fiber1在内部把控制权转交给主线程，这个时候主线程继续往下执行，开始调度fiber3。故而最后的输出结果是

```
In Fiber 2
In Fiber 1
In Fiber 3
```

(Thread)[http://merbist.com/2011/02/22/concurrency-in-ruby-explained/]
(Nice)[http://oldmoe.blogspot.jp/2008/08/ruby-fibers-vs-ruby-threads.html]

咋一看这个例子似乎没有什么特别，虽然它可以让我们很方便地调度三个协程实例的执行顺序，但是其实这种控制流我们平时所写的串行程序也能够实现，只需要定义三个方法，然后按照上面的顺序去调用就行了。那我下面再举一个例子


``` ruby
fiber1 = Fiber.new do
  puts "fiber1 first resume"
  Fiber.yield
  puts "fiber1 second resume"
  Fiber.yield
  puts "fiber1 third resume"
end


fiber2 = Fiber.new do
  puts "fiber2 first resume"
  Fiber.yield
  puts "fiber2 second resume"
end

fiber1.resume #1
fiber2.resume #2
fiber2.resume #3
fiber1.resume #4
fiber1.resume #5

fiber1.resume #6
```

大家看看猜一下这段代码会输出什么？答案是

```
fiber1 first resume
fiber2 first resume
fiber2 second resume
fiber1 second resume
fiber1 third resume
tread.rb:22:in `resume': dead fiber called (FiberError)
	from tread.rb:22:in `<main>'
```

代码分析: 我们首先创建fiber1, fiber2这两个实例，然后先在主线程调度fiber1(代码#1)，fiber1输出了第一次被调度的信息，然后通过`Fiber#yield`让出控制权给主线程，然后主线程继续执行代码调度fiber2(代码#2)，fiber2同样输出了自己第一次被调度的信息之后就通过`Fiber#yield`让出控制权给主线程，然后主线程继续往下执行代码#3以同样的方式fiber2输出了自己第二次被调度的信息之后就完成了所有任务了，它便主动让出控制权，然后主线程接着执行#4,#5,#6代码。#6这段代码我特地空了一行，表示在#5的时候fiber1已经完成任务了，如果再次调度的话就会报错，警告我们已经`死去`的fiber被调度了。

如果用串行代码来实现上面这么诡异的控制流会有点困难吧，这也是协程的可贵之处，线程之间似乎是在相互协作一起工作着。得益于这种特性我们可以写出吞吐量更高的Web服务。在Python领域就有一款叫Tornado的框架非常火热。

### 5) 并行

既然官方版本的Ruby(MRI)会加上GIL导致我们没有办法活用CPU的多核，使得我们只能够实现并发操作，并没有办法实现并行。既然GIL这么碍事，拿掉不就好了？

回到最初的故事，如果小蓝跟小张的除草任务不需要用锄头就能够完成，或者人手都有一把锄头的话，那么两个人就能够在同一时刻进行除草任务了，只要安排合理，势必会比一个人进行除草任务更高效，这便是并行的工作方式。

在Ruby的世界中确实存在一些已经去除了GIL的实现，其中包括[rubinius](https://github.com/rubinius/rubinius) 以及 [jruby](https://github.com/jruby/jruby)他们的底层分别用的是C++以及Java的实现，他们都有着比MRI更好的性能。详细比较可以猛戳[这里](https://www.toptal.com/ruby/the-many-shades-of-the-ruby-programming-language)。另外目前比较火的Rails服务器[Puma](http://puma.io/)也说到

```
Today, Puma runs on all Ruby implementations, but will always run best on any implementation that provides true parallelism.
```

或许得益于这些Ruby的实现，以后像Rails这些Web框架将会有更好的性能吧。


## 2. 尾声

以上是我最近查阅资料对于并发，线程，进程，并行这些概念的总结，如果有所误解的还望指正，所有的动画例子为了方便起见我都用JavaScript实现，代码托管到[这里]()，也算是几个简单的小动画吧，前端初学者可以用来做Demo参考。

很感谢你能读到这里

# Happy Coding and writing!!!
