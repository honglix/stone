---
layout: post
title: 瞎扯Ruby里的生成器
slug: xia-che-Ruby-li-de-sheng-cheng-qi
---
在老东家写了Python一段时间后，我被同事告知Python里面有个很经典的被称之为生成器的特性。这个特性一直让我念念不忘，毕竟掌握它之后我一度觉得自己很酷。后来我接触了Ruby，我就纳闷了Ruby怎么就没看到这个特性？

> 图片

直到最近在读《松本行弘的程序员世界》的时候我才意识到我错了，这个特性早在Ruby1.9就已经具备，只不过是我资历尚浅，察觉不到它的存在罢了。

## 1. Python使用yield语句创建生成器

下面是一个简单的Python生成器遍历0-max范围内的所有数字

``` python
def range(max):
    n = 0
    while n < max:
        yield n
        n += 1

if __name__ == '__main__':
    for i in range(100):
        print(i)
```

> PS: 结果就是打印0~99这里就不贴出来了。

有没有感觉这个函数很有梯度感？这是我放弃Python的理由之一。如果我们直接在REPL环境里面运行`range`方法，会得到下面的结果

```
In [8]: range(100)
Out[8]: <generator object range at 0x102f41460>
```

可以看出它是一个`generator`，也就是我们所说的生成器。

**当然，我们也可以直接构造一个数组来完成以上的打印过程，但生成器的好处就是它是惰性的，也就是说当你访问某个元素的时候对应元素才会被生成，而不是在遍历之前就已经生成完整的数组列表，然后我们再去遍历它。**

## 2. Ruby的yield

现在我们看看Ruby的yield语句是用来做什么的，举个简单的例子就能够看出来

``` ruby
def handler(a)
  yield(a)
end

result = handler(100) { |i| i * 20 }

puts result
```

程序的运行结果是

```
> 2000
```

**简单来说，Ruby里面的yield可以用来接收方法块，调用它就相当于调用方法块。**上面的例子里我们的方法块是`{ |i| i * 20 }`，它接收一个参数`i`并返回`i * 20`，结果就是 `100 * 20 = 2000`

## 3. Ruby中的生成器

那问题来了，`yield`这个语句已经被用作方法块的代理了，那我们在Ruby里面要怎么实现如Python般的生成器？还是说Ruby中压根就没有生成器？

怎么可能呢？生成器就在我们身边，只不过我们很多时候都察觉不到它的存在，具体我们可以参考一下[这篇文章](https://stackoverflow.com/questions/9052621/why-do-we-need-fibers)。在Ruby1.9之后就实现了`Enumerator`这个类，它的机制跟Python里面的生成器类似，可以用作惰性求值。使用方式如下

```
> a = (1..100000000000000000).each
=> #<Enumerator: 1..100000000000000000:each>
> a.next
=> 1
> a.next
=> 2
> a.next
=> 3
> a.next
=> 4
> a.next
=> 5
```

这里我使用了ruby的范围字面量，有点编程经验的朋友都知道，我们应该不可能活着看到我们的计算机生成长度为100000000000000000的数组，所以这里一定有什么黑魔法。它实质上是通过each方法返回了`Enumerator`对象，它是一个外部迭代器，我们可以通过依次调用`next`方法来获取下一个索引所对应的数值，访问到对应的下标的时候才会生成对应的数值，这就是我所期待的生成器。

## 4. 模拟生成器

Ruby1.9之后Ruby提供了名为Fiber的类，主要用于构建轻量级的协程。它让我们的代码块可以像线程那样被停止与唤醒。我想如果控制流都归我管了，那我或许能够用它来模拟一下生成器了吧。

下面举一个简单的例子

``` ruby
fiber = Fiber.new do
  Fiber.yield 1
  2
end

puts fiber.resume
puts fiber.resume
puts fiber.resume
```

`Fiber::yield`的作用跟Python中的`yield`语法有点类似。这里我们通过`Fiber#new`语句来创建Fiber实例，并传递一个代码块。**我们可以把`Fiber::yield`想象成类似于`byebug`或者`binding.pry`等调试语句，程序运行到这里就会暂停，然后把控制权让出去。**

当我们第一次运行`Fiber#resume`方法的时候就会返回`Fiber::yield`后面的值，而第二次执行`Fiber#resume`就会继续运行代码块余下的代码并返回`2`，第三次运行`Fiber#resume`的时候由于我们块已经执行完毕所以会报错

``` irb
> fiber.resume
=> 1
> fiber.resume
=> 2
> fiber.resume
FiberError: dead fiber called
	from (irb):7:in `resume'
	from (irb):7
```

那么这个玩意到底有什么用呢？我们现在来谈协程这些多线程的东西似乎有点早。那现在先不谈协程，单纯用它来模拟Python中的生成器。

**简单地去理解，在Python里面含有`yield`语句的方法被调用之后会返回一个生成器对象，然后我们可以利用这个生成器来进行惰性求值（个人感觉这种语法不够清爽，没有一个显式的返回语句，把生成器对象返回）**

下面是我YY出来的用Ruby的生成器特性来实现的函数，它的功能类似文章开头用Python实现的函数

``` ruby
def range(n)
  Fiber.new do
    i = 0
    while i < n
      Fiber.yield i
      i += 1
    end
  end
end

fiber = range(10)

p fiber.resume
p fiber.resume
p fiber.resume
p fiber.resume
```

上面脚本的输出是

``` irb
0
1
2
3
```

> 跟Python版本的另一个区别是，Python的版本里使用了for语句来迭代生成器，我这里只是简单地手动去迭代。

我们的range方法返回了一个`Fiber`对象，它就相当于一个生成器（或者也可以说是一个外部的迭代器），通过反复调用`Fiber#resume`方法就可以获取下一个值，如果反复调用超出限制就会报错。我`Fiber#resume`10次之后就会得到下面的结果。

下面是报错信息

``` irb
dead fiber called (FiberError)
```


## 5. 总结

瞎扯了一下Ruby的生成器，作为一个特性，它并不像Python那么明显，但是它确实存在着。另外，得益于`Fiber`这种类库的出现，已经有些多线程的库被开发出来了，据说性能方面比原来Ruby内置的`Thread`要好一些，具体的比较我想放在后面的文章再详细讨论，很感谢你能够看到这里。


# Happy Coding and Writing !!
