---
layout: post
title: Ruby优化逆行
---
## 引言

我们大多数人都希望有一个更快的Ruby实现，作为一门编程语言，它通常都坐在性能表的底部，即便一些人宣称这没有关系因为他们的Ruby代码是IO密集型的，他们会把有性能问题的部分用其他的像C或者Java这样的语言重写，但如果你不需要去做这些事情不也很好吗，Ruby是否可能是一门拥有高性能的同时又能为我们编程带来快乐的语言？

这个事情至今没有发生，理由是Ruby已经被证明了要优化它是异常困难的。它有很多能提高编程人员生产力的特性，但是这些特性很难被高效地实现。我们将会在后面看到一些例子，包括`Fixnum`到`Bignum`的提升，猴子布丁，方法，`#binding`，`ObjectSpace`，`set_trace_func`以及`Thread#raise`.

这些特性都很难实现因为他们需要你持续检查一些东西-检查一个计算是否越界，检查一个方法是否被重定义，检查一个跟踪函功能是否已经载入，检查你是否应该停止当前的线程等等。所有的这些检查都会大量地花费时间以及空间-时间花费在检查上，空间花费在需要检查发生的指令缓存区。这些检查迅速堆积很快你的检查工作会比你实际需要做的有用的工作更多。要优化这些检测是很困难的。~~举个例子你不可能只检测一个东西一次，然后假设它在剩下的方法中都是正常的。其他线程中的方法可能会改变一些东西。~~

这其中有些特性会使实现变得困难，因为很难在它们身上采用其他语言所使用的简单和直观的优化。像是把Ruby的本地变量存储在栈上或者是在栈上而不是在堆上分配一个对象空间。

一个典型的能够提升Ruby性能的策略是使用just-in-time编译器。这意味着我们会在程序运行的时候把Ruby编译成机器代码。这项技术在JRuby以及Rubinius里面被使用着。然而即便有许多伟大的工作成果，然而这些实现都没能够把性能提高一个指数的量级。

这个问题的解决方案是一个被称为逆行优化的技术。逆行优化意味着从更多的优化代码转向更少的优化代码。实际上，这通常意味着从just-in-time编译成机器码的策略跳回解释器。如果我们可以在任意点上都做到，并且如果我们可以完美地回退整个解释器的状态，然后我们可以开始从优化过的代码中抛弃那些检查，并且我们可以在检查失败的时候逆行优化。

包括JRuby和Rubinius许多Ruby的实现或多或少的采用了逆行优化的一些模式，但是却没有Truffle把逆行优化运用得那么普遍或者说那么激进，它是为JRuby准备的一个高性能的后台。JRuby+Truffle是一个Oracle Labs的研究项目并且现在已经是JRuby的一个开源组件。它为JVM使用了一个新的用Java写的just-in-time编译器被称为Graal。Graal是一个Java的包并不是原生的机器代码，它可以暴露一个Java的API，程序可以直接使用它去控制just-in-time编译器。这是个强大的功能却有点狡猾，因此一个被成为Truffle的框架通过带来了一个高性能的Ruby解释器并使用Graal来生成机器码来协助我们。JRuby+Tuffle并没有字节码格式-它直接从高级的解释器中变成了机器代码。

这篇博客文章是我们RubyConf 2014 Talk的一个好伴侣，Ruby逆行优化。我们在这里提供一些只是背景以及有技术深度的东西，并提供一些我们可以找到更多信息的连接。

![Video](https://youtu.be/z-YVygbDHLE)

## 为什么Ruby难以优化
